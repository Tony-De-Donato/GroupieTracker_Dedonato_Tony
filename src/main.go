package main

import (
	"encoding/json"
	"fmt"
	"html/template"
	"net/http"
	"strings"
)

type AutoGenerated struct {
	Status int `json:"status"`
	Data   struct {
		UUID                      string   `json:"uuid"`
		DisplayName               string   `json:"displayName"`
		Description               string   `json:"description"`
		DeveloperName             string   `json:"developerName"`
		CharacterTags             any      `json:"characterTags"`
		DisplayIcon               string   `json:"displayIcon"`
		DisplayIconSmall          string   `json:"displayIconSmall"`
		BustPortrait              string   `json:"bustPortrait"`
		FullPortrait              string   `json:"fullPortrait"`
		FullPortraitV2            string   `json:"fullPortraitV2"`
		KillfeedPortrait          string   `json:"killfeedPortrait"`
		Background                string   `json:"background"`
		BackgroundGradientColors  []string `json:"backgroundGradientColors"`
		AssetPath                 string   `json:"assetPath"`
		IsFullPortraitRightFacing bool     `json:"isFullPortraitRightFacing"`
		IsPlayableCharacter       bool     `json:"isPlayableCharacter"`
		IsAvailableForTest        bool     `json:"isAvailableForTest"`
		IsBaseContent             bool     `json:"isBaseContent"`
		Role                      struct {
			UUID        string `json:"uuid"`
			DisplayName string `json:"displayName"`
			Description string `json:"description"`
			DisplayIcon string `json:"displayIcon"`
			AssetPath   string `json:"assetPath"`
		} `json:"role"`
		Abilities []struct {
			Slot        string `json:"slot"`
			DisplayName string `json:"displayName"`
			Description string `json:"description"`
			DisplayIcon string `json:"displayIcon"`
		} `json:"abilities"`
		VoiceLine struct {
			MinDuration float64 `json:"minDuration"`
			MaxDuration float64 `json:"maxDuration"`
			MediaList   []struct {
				ID    int    `json:"id"`
				Wwise string `json:"wwise"`
				Wave  string `json:"wave"`
			} `json:"mediaList"`
		} `json:"voiceLine"`
	} `json:"data"`
}

type Agent struct {
	Status int `json:"status"`
	Data   []struct {
		UUID          string `json:"uuid"`
		DisplayName   string `json:"displayName"`
		Description   string `json:"description"`
		DeveloperName string `json:"developerName"`
		DisplayIcon   string `json:"displayIcon"`
		BustPortrait  string `json:"bustPortrait"`
		FullPortrait  string `json:"fullPortrait"`
		Abilities     []struct {
			DisplayName string `json:"displayName"`
			Description string `json:"description"`
			DisplayIcon string `json:"displayIcon"`
		} `json:"abilities"`
	} `json:"data"`
}

func main() {
	fmt.Println("(http://localhost:80)")

	index()

	Api()

	Page_perso()

	http.ListenAndServe(":80", nil)

}

func index() {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		liste_des_fichiers := append([]string{
			"elements/index.html",
			"elements/liste-perso.html",
			"elements/header.html",
			"elements/api.html"}, "elements/Premiere_arrivee.html")
		tmpl := template.Must(template.ParseFiles(liste_des_fichiers...))
		tmpl.Execute(w, nil)
	})
}

func Api() {
	http.HandleFunc("/api", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			liste_des_fichiers := append([]string{
				"elements/index.html",
				"elements/liste-perso.html",
				"elements/header.html",
				"elements/api.html"}, "elements/premiere_entree.html")
			tmpl := template.Must(template.ParseFiles(liste_des_fichiers...))
			tmpl.Execute(w, nil)
			return
		}
		listPerso := recup_perso(r.FormValue("perso"))
		liste_des_fichiers := append([]string{
			"elements/index.html",
			"elements/liste-perso.html",
			"elements/header.html",
			"elements/api.html"}, "elements/api.html")
		tmpl := template.Must(template.ParseFiles(liste_des_fichiers...))
		tmpl.Execute(w, listPerso)
	})
}

func Page_perso() {
	http.HandleFunc("/perso", func(w http.ResponseWriter, r *http.Request) {
		uuid := strings.TrimPrefix(r.URL.RequestURI(), "/perso?id=")
		chara := recup_perso_precis(uuid)
		liste_des_fichiers := append([]string{
			"elements/index.html",
			"elements/liste-perso.html",
			"elements/header.html",
			"elements/api.html"}, "elements/agent.html")
		tmpl := template.Must(template.ParseFiles(liste_des_fichiers...))
		tmpl.Execute(w, chara)
		return
	})
}

func recup_perso(text string) Agent {

	url := "https://valorant-api.com/v1/agents"

	resp, err := http.Get(url)
	if err != nil {
		fmt.Println("Erreur de demande : ", err)

	}

	defer resp.Body.Close()

	var agent2 Agent
	err = json.NewDecoder(resp.Body).Decode(&agent2)
	if err != nil {
		fmt.Println("Erreur de décodage JSON 1: ", err)
	}
	var agent Agent
	for _, element := range agent2.Data {
		if make_request_usable(element.DisplayName, text) {
			agent.Data = append(agent.Data, element)
		}
	}
	return agent
}

func recup_perso_precis(uuid string) AutoGenerated {

	url := "https://valorant-api.com/v1/agents/" + uuid

	resp, err := http.Get(url)
	if err != nil {
		fmt.Println("Erreur de demande : ", err)

	}

	defer resp.Body.Close()

	var agent AutoGenerated
	err = json.NewDecoder(resp.Body).Decode(&agent)
	if err != nil {
		fmt.Println("Erreur de décodage JSON 2: ", err, " ", url)
	}
	return agent
}

func make_request_usable(nom_perso string, text string) bool {
	resultat := false
	nom_perso = strings.ToLower(nom_perso)
	text = strings.ToLower(text)
	if strings.Contains(nom_perso, text) {
		resultat = true
	}
	return resultat
}
